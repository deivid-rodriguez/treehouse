# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ox` gem.
# Please instead update this file by running `bin/tapioca gem ox`.

# === Description:
#
# Ox handles XML documents in two ways. It is a generic XML parser and writer as
# well as a fast Object / XML marshaller. Ox was written for speed as a
# replacement for Nokogiri and for Marshal.
#
# As an XML parser it is 2 or more times faster than Nokogiri and as a generic
# XML writer it is 14 times faster than Nokogiri. Of course different files may
# result in slightly different times.
#
# As an Object serializer Ox is 4 times faster than the standard Ruby
# Marshal.dump(). Ox is 3 times faster than Marshal.load().
#
# === Object Dump Sample:
#
#   require 'ox'
#
#   class Sample
#     attr_accessor :a, :b, :c
#
#     def initialize(a, b, c)
#       @a = a
#       @b = b
#       @c = c
#     end
#   end
#
#   # Create Object
#   obj = Sample.new(1, "bee", ['x', :y, 7.0])
#   # Now dump the Object to an XML String.
#   xml = Ox.dump(obj)
#   # Convert the object back into a Sample Object.
#   obj2 = Ox.parse_obj(xml)
#
# === Generic XML Writing and Parsing:
#
#   require 'ox'
#
#   doc = Ox::Document.new(:version => '1.0')
#
#   top = Ox::Element.new('top')
#   top[:name] = 'sample'
#   doc << top
#
#   mid = Ox::Element.new('middle')
#   mid[:name] = 'second'
#   top << mid
#
#   bot = Ox::Element.new('bottom')
#   bot[:name] = 'third'
#   mid << bot
#
#   xml = Ox.dump(doc)
#   puts xml
#   doc2 = Ox.parse(xml)
#   puts "Same? #{doc == doc2}"
#
# source://ox//lib/ox.rb#61
module Ox
  private

  def default_options; end
  def default_options=(_arg0); end
  def dump(*_arg0); end
  def load(*_arg0); end
  def load_file(*_arg0); end
  def parse(_arg0); end
  def parse_obj(_arg0); end
  def sax_html(*_arg0); end
  def sax_html_overlay; end
  def sax_parse(*_arg0); end
  def to_file(*_arg0); end
  def to_xml(*_arg0); end

  class << self
    def default_options; end
    def default_options=(_arg0); end
    def dump(*_arg0); end
    def load(*_arg0); end
    def load_file(*_arg0); end
    def parse(_arg0); end
    def parse_obj(_arg0); end
    def sax_html(*_arg0); end
    def sax_html_overlay; end
    def sax_parse(*_arg0); end
    def to_file(*_arg0); end
    def to_xml(*_arg0); end
  end
end

# An Exception that is raised as a result of an invalid argument.
#
# source://ox//lib/ox/error.rb#11
class Ox::ArgError < ::Ox::Error; end

# A generic class that is used only for storing attributes. It is the base
# Class for auto-generated classes in the storage system. Instance variables
# are added using the instance_variable_set() method. All instance variables
# can be accessed using the variable name (without the @ prefix). No setters
# are provided as the Class is intended for reading only.
#
# source://ox//lib/ox/bag.rb#7
class Ox::Bag
  # The initializer can take multiple arguments in the form of key values
  # where the key is the variable name and the value is the variable
  # value. This is intended for testing purposes only.
  # - +args+ [Hash] instance variable symbols and their values
  #
  # *Example*
  #
  #  Ox::Bag.new(:@x => 42, :@y => 57)
  #
  # @return [Bag] a new instance of Bag
  #
  # source://ox//lib/ox/bag.rb#17
  def initialize(args = T.unsafe(nil)); end

  # Replaces eql?() with something more reasonable for this Class.
  # - +other+ [Object] Object to compare self to
  # *return* [Boolean] true if each variable and value are the same, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/bag.rb#56
  def ==(other); end

  # Replaces eql?() with something more reasonable for this Class.
  # - +other+ [Object] Object to compare self to
  # *return* [Boolean] true if each variable and value are the same, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/bag.rb#56
  def eql?(other); end

  # Handles requests for variable values. Others cause an Exception to be
  # raised.
  # - +m+ (Symbol) method symbol
  # *return* [Boolean] the value of the specified instance variable.
  #
  # _raise_ [ArgumentError] if an argument is given. Zero arguments expected.
  #
  # _raise_ [NoMethodError] if the instance variable is not defined.
  #
  # @raise [NoMethodError]
  #
  # source://ox//lib/ox/bag.rb#42
  def method_missing(m, *args, &block); end

  # Replaces the Object.respond_to?() method.
  # - +m+ [Symbol] method symbol
  # *return* [Boolean] true for any method that matches an instance variable
  # reader, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/bag.rb#27
  def respond_to?(m); end

  class << self
    # Define a new class based on the Ox::Bag class. This is used internally in
    # the Ox module and is available to service wrappers that receive XML
    # requests that include Objects of Classes not defined in the storage
    # process.
    # - +classname+ (String) Class name or symbol that includes Module names.
    # *return* [Object] an instance of the specified Class.
    #
    # _raise_ [NameError] if the classname is invalid.
    #
    # @raise [NameError]
    #
    # source://ox//lib/ox/bag.rb#78
    def define_class(classname); end
  end
end

class Ox::Builder
  def cdata(_arg0); end
  def close; end
  def column; end
  def comment(_arg0); end
  def doctype(_arg0); end
  def element(*_arg0); end
  def indent; end
  def indent=(_arg0); end
  def instruct(*_arg0); end
  def line; end
  def pop; end
  def pos; end
  def raw(_arg0); end
  def text(*_arg0); end
  def to_s; end
  def void_element(*_arg0); end

  private

  def file(*_arg0); end
  def io(*_arg0); end
  def new(*_arg0); end

  class << self
    def file(*_arg0); end
    def io(*_arg0); end
    def new(*_arg0); end
  end
end

# CData represents a CDATA element in an XML document.
#
# source://ox//lib/ox/cdata.rb#3
class Ox::CData < ::Ox::Node
  # Creates a CDATA element.
  # - +value+ [String] value for the CDATA contents
  #
  # @return [CData] a new instance of CData
  #
  # source://ox//lib/ox/cdata.rb#6
  def initialize(value); end
end

class Ox::Cache; end

# Comments represent XML comments in an XML document. A comment has a value
# attribute only.
#
# source://ox//lib/ox/comment.rb#4
class Ox::Comment < ::Ox::Node
  # Creates a new Comment with the specified value.
  # - +value+ [String] string value for the comment
  #
  # @return [Comment] a new instance of Comment
  #
  # source://ox//lib/ox/comment.rb#7
  def initialize(value); end
end

# Represents a DOCTYPE in an XML document.
#
# source://ox//lib/ox/doctype.rb#3
class Ox::DocType < ::Ox::Node
  # Creates a DOCTYPE elements with the content as a string specified in the
  # value parameter.
  # - +value+ [String] string value for the element
  #
  # @return [DocType] a new instance of DocType
  #
  # source://ox//lib/ox/doctype.rb#7
  def initialize(value); end
end

# Represents an XML document. It has a fixed set of attributes which form
# the XML prolog. A Document includes Elements.
#
# source://ox//lib/ox/document.rb#4
class Ox::Document < ::Ox::Element
  # Create a new Document.
  # - +prolog+ [Hash] prolog attributes
  #   - _:version_ [String] version, typically '1.0' or '1.1'
  #   - _:encoding_ [String] encoding for the document, currently included but ignored
  #   - _:standalone_ [String] indicates the document is standalone
  #
  # @return [Document] a new instance of Document
  #
  # source://ox//lib/ox/document.rb#10
  def initialize(prolog = T.unsafe(nil)); end

  # Returns the first Element in the document.
  #
  # source://ox//lib/ox/document.rb#19
  def root; end
end

# An Element represents a element of an XML document. It has a name,
# attributes, and sub-nodes.
#
# To access the child elements or attributes there are several options. One
# is to walk the nodes and attributes. Another is to use the locate()
# method. The easiest for simple regularly formatted XML is to reference the
# sub elements or attributes simply by name. Repeating elements with the
# same name can be referenced with an element count as well. A few examples
# should explain the 'easy' API more clearly.
#
# *Example*
#
#   doc = Ox.parse(%{
#   <?xml?>
#   <People>
#     <Person age="58">
#       <given>Peter</given>
#       <surname>Ohler</surname>
#     </Person>
#     <Person>
#       <given>Makie</given>
#       <surname>Ohler</surname>
#     </Person>
#   </People>
#   })
#
#   doc.People.Person.given.text
#   => "Peter"
#   doc.People.Person(1).given.text
#   => "Makie"
#   doc.People.Person.age
#   => "58"
#
# source://ox//lib/ox/element.rb#34
class Ox::Element < ::Ox::Node
  include ::Ox::HasAttrs

  # Creates a new Element with the specified name.
  # - +name+ [String] name of the Element
  #
  # @return [Element] a new instance of Element
  #
  # source://ox//lib/ox/element.rb#39
  def initialize(name); end

  # Appends a Node to the Element's nodes array. Returns the element itself
  # so multiple appends can be chained together.
  # - +node+ [Node] Node to append to the nodes array
  #
  # source://ox//lib/ox/element.rb#58
  def <<(node); end

  # Returns true if this Object and other are of the same type and have the
  # equivalent value and the equivalent elements otherwise false is returned.
  # - +other+ [Object] Object compare _self_ to.
  # *return* [Boolean] true if both Objects are equivalent, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/element.rb#81
  def ==(other); end

  # - +path+ [Array] array of steps in a path
  # - +found+ [Array] matching nodes
  #
  # source://ox//lib/ox/element.rb#255
  def alocate(path, found); end

  # Return true if all the key-value pairs in the cond Hash match the
  #
  # source://ox//lib/ox/element.rb#109
  def attr_match(cond); end

  # - +path+ [Array] array of steps in a path
  #
  # source://ox//lib/ox/element.rb#338
  def del_locate(path); end

  # Iterate over each child of the instance yielding according to the cond
  # argument value. If the cond argument is nil then all child nodes are
  # yielded to. If cond is a string then only the child Elements with a
  # matching name will be yielded to. If the cond is a Hash then the
  # keys-value pairs in the cond must match the child attribute values with
  # the same keys. Any other cond type will yield to nothing.
  #
  # source://ox//lib/ox/element.rb#120
  def each(cond = T.unsafe(nil), &block); end

  # Returns true if this Object and other are of the same type and have the
  # equivalent value and the equivalent elements otherwise false is returned.
  # - +other+ [Object] Object compare _self_ to.
  # *return* [Boolean] true if both Objects are equivalent, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/element.rb#81
  def eql?(other); end

  # Returns an array of Nodes or Strings that correspond to the locations
  # specified by the path parameter. The path parameter describes the path
  # to the return values which can be either nodes in the XML or
  # attributes. The path is a relative description. There are similarities
  # between the locate() method and XPath but locate does not follow the
  # same rules as XPath. The syntax is meant to be simpler and more Ruby
  # like.
  #
  # Like XPath the path delimiters are the slash (/) character. The path is
  # split on the delimiter and each element of the path then describes the
  # child of the current Element to traverse.
  #
  # Attributes are specified with an @ prefix.
  #
  # Each element name in the path can be followed by a bracket expression
  # that narrows the paths to traverse. Supported expressions are numbers
  # with a preceeding qualifier. Qualifiers are -, +, <, and >. The +
  # qualifier is the default. A - qualifier indicates the index begins at
  # the end of the children just like for Ruby Arrays. The < and >
  # qualifiers indicates all elements either less than or greater than
  # should be matched. Note that unlike XPath, the element index starts at 0
  # similar to Ruby be contrary to XPath.
  #
  # Element names can also be wildcard characters. A * indicates any decendent should be followed. A ? indicates any
  # single Element can match the wildcard. A ^ character followed by the name of a Class will match any node of the
  # specified class. Valid class names are Element, Comment, String (or Text), CData, DocType.
  #
  # Examples are:
  # * <code>element.locate("Family/Pete/*")</code> returns all children of the Pete Element.
  # * <code>element.locate("Family/?[1]")</code> returns the first element in the Family Element.
  # * <code>element.locate("Family/?[<3]")</code> returns the first 3 elements in the Family Element.
  # * <code>element.locate("Family/?[@age]")</code> returns the elements with an age attribute defined in the Family Element.
  # * <code>element.locate("Family/Kid[@age]")</code> returns the Kid elements with an age attribute defined in the Family Element.
  # * <code>element.locate("Family/?[@age=32]")</code> returns the elements with an age attribute equal to 32 in the Family Element.
  # * <code>element.locate("Family/Kid[@age=32]")</code> returns the Kid elements with an age attribute equal to 32 in the Family Element.
  # * <code>element.locate("Family/?/@age")</code> returns the arg attribute for each child in the Family Element.
  # * <code>element.locate("Family/*/@type")</code> returns the type attribute value for decendents of the Family.
  # * <code>element.locate("Family/^Comment")</code> returns any comments that are a child of Family.
  #
  # - +path+ [String] path to the Nodes to locate
  #
  # source://ox//lib/ox/element.rb#164
  def locate(path); end

  # Handles the 'easy' API that allows navigating a simple XML by
  # referencing elements and attributes by name.
  # - +id+ [Symbol] element or attribute name
  # *return* [Element|Node|String|nil] the element, attribute value, or Node identifed by the name
  #
  # _raise_ [NoMethodError] if no match is found
  #
  # @raise [NoMethodError]
  #
  # source://ox//lib/ox/element.rb#212
  def method_missing(id, *args, &block); end

  # source://ox//lib/ox/node.rb#5
  def name; end

  # source://ox//lib/ox/node.rb#5
  def name=(_arg0); end

  # Returns the Element's nodes array. These are the sub-elements of this
  # Element.
  # *return* [Array] all child Nodes.
  #
  # source://ox//lib/ox/element.rb#50
  def nodes; end

  # Prepend a Node to the Element's nodes array. Returns the element itself
  # so multiple appends can be chained together.
  # - +node+ [Node] Node to prepend to the nodes array
  #
  # source://ox//lib/ox/element.rb#69
  def prepend_child(node); end

  # Remove all the children matching the path provided
  #
  # Examples are:
  # * <code>element.remove_children(Ox:Element)</code> removes the element passed as argument if child of the element.
  # * <code>element.remove_children(Ox:Element, Ox:Element)</code> removes the list of elements passed as argument if children of the element.
  #
  # - +children+ [Array] array of OX
  #
  # source://ox//lib/ox/element.rb#187
  def remove_children(*children); end

  # Remove all the children matching the path provided
  #
  # Examples are:
  # * <code>element.remove_children_by_path("*")</code> removes all children attributes.
  # * <code>element.remove_children_by_path("Family/Kid[@age=32]")</code> removes the Kid elements with an age attribute equal to 32 in the Family Element.
  #
  # - +path+ [String] path to the Nodes to locate
  #
  # source://ox//lib/ox/element.rb#201
  def remove_children_by_path(path); end

  # Clears any child nodes of an element and replaces those with a single Text
  # (String) node. Note the existing nodes array is modified and not replaced.
  # - +txt+ [String] to become the only element of the nodes array
  #
  # source://ox//lib/ox/element.rb#100
  def replace_text(txt); end

  # - +id+ [String|Symbol] identifer of the attribute or method
  # - +ignored+ inc_all [Boolean]
  # *return* true if the element has a member that matches the provided name.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/element.rb#237
  def respond_to?(id, inc_all = T.unsafe(nil)); end

  # Returns the first String in the elements nodes array or nil if there is
  # no String node.
  #
  # source://ox//lib/ox/element.rb#92
  def text; end

  private

  # Builds an enumerator for use in `#each` call
  #
  # - +cond+ [Hash, String, nil] an element filter
  #
  # source://ox//lib/ox/element.rb#423
  def build_enumerator(cond); end

  # @return [Boolean]
  #
  # source://ox//lib/ox/element.rb#453
  def name_matchs?(pat, id); end

  # Removes recursively children for nodes and sub_nodes
  #
  # - +found+ [Array] An array of Ox::Element
  #
  # source://ox//lib/ox/element.rb#441
  def recursive_children_removal(found); end
end

# Base error class for Ox errors.
#
# source://ox//lib/ox/error.rb#3
class Ox::Error < ::StandardError; end

# An Object that includes the HasAttrs module can have attributes which are a Hash of String values and either String
# or Symbol keys.
#
# To access the attributes there are several options. One is to walk the attributes. The easiest for simple regularly
# formatted XML is to reference the attributes simply by name.
#
# source://ox//lib/ox/hasattrs.rb#7
module Ox::HasAttrs
  # Returns the value of an attribute.
  # - +attr+ [Symbol|String] attribute name or key to return the value for
  #
  # source://ox//lib/ox/hasattrs.rb#17
  def [](attr); end

  # Adds or set an attribute of the Instruct.
  # - +attr+ [Symbol|String] attribute name or key
  # - +value+ [Object] value for the attribute
  #
  # source://ox//lib/ox/hasattrs.rb#26
  def []=(attr, value); end

  # Returns all the attributes of the Instruct as a Hash.
  # *return* [Hash] all attributes and attribute values.
  #
  # source://ox//lib/ox/hasattrs.rb#10
  def attributes; end

  # Handles the 'easy' API that allows navigating a simple XML by
  # referencing attributes by name.
  # - +id+ [Symbol] element or attribute name
  # *return* [String|nil] the attribute value
  # _raise_ [NoMethodError] if no match is found
  #
  # @raise [NoMethodError]
  #
  # source://ox//lib/ox/hasattrs.rb#45
  def method_missing(id, *args, &block); end
end

# An Instruct represents a processing instruction of an XML document. It has a target, attributes, and a value or
# content. The content will be all characters with the exception of the target. If the content follows a regular
# attribute format then the attributes will be set to the parsed values. If it does not follow the attribute formate
# then the attributes will be empty.
#
# source://ox//lib/ox/instruct.rb#6
class Ox::Instruct < ::Ox::Node
  include ::Ox::HasAttrs

  # Creates a new Instruct with the specified name.
  # - +name+ [String] name of the Instruct
  #
  # @return [Instruct] a new instance of Instruct
  #
  # source://ox//lib/ox/instruct.rb#14
  def initialize(name); end

  # Returns true if this Object and other are of the same type and have the
  # equivalent value and the equivalent elements otherwise false is returned.
  # - +other+ [Object] Object compare _self_ to.
  # *return* [Boolean] true if both Objects are equivalent, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/instruct.rb#25
  def ==(other); end

  # The content of the processing instruction.
  #
  # source://ox//lib/ox/instruct.rb#10
  def content; end

  # The content of the processing instruction.
  #
  # source://ox//lib/ox/instruct.rb#10
  def content=(_arg0); end

  # Returns true if this Object and other are of the same type and have the
  # equivalent value and the equivalent elements otherwise false is returned.
  # - +other+ [Object] Object compare _self_ to.
  # *return* [Boolean] true if both Objects are equivalent, otherwise false.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/instruct.rb#25
  def eql?(other); end

  # source://ox//lib/ox/node.rb#5
  def target; end
end

# An Exception raised if a path is not valid.
#
# source://ox//lib/ox/error.rb#19
class Ox::InvalidPath < ::Ox::Error
  # Create a new instance with the +path+ specified.
  #
  # @return [InvalidPath] a new instance of InvalidPath
  #
  # source://ox//lib/ox/error.rb#21
  def initialize(path); end
end

# The Node is the base class for all other in the Ox module.
#
# source://ox//lib/ox/node.rb#3
class Ox::Node
  # Creates a new Node with the specified String value.
  # - +value+ [String] string value for the Node
  #
  # @return [Node] a new instance of Node
  #
  # source://ox//lib/ox/node.rb#9
  def initialize(value); end

  # Returns true if this Object and other are of the same type and have the
  # equivalent value otherwise false is returned.
  # - +other+ [Object] Object to compare _self_ to.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/node.rb#16
  def ==(other); end

  # Returns true if this Object and other are of the same type and have the
  # equivalent value otherwise false is returned.
  # - +other+ [Object] Object to compare _self_ to.
  #
  # @return [Boolean]
  #
  # source://ox//lib/ox/node.rb#16
  def eql?(other); end

  # String value associated with the Node.
  #
  # source://ox//lib/ox/node.rb#5
  def value; end

  # String value associated with the Node.
  #
  # source://ox//lib/ox/node.rb#5
  def value=(_arg0); end
end

# An Exception that is raised as a result of a parse error while parsing a XML document.
#
# source://ox//lib/ox/error.rb#7
class Ox::ParseError < ::Ox::Error; end

# Raw elements are used to inject existing XML strings into a document
# WARNING: Use of this feature can result in invalid XML, since `value` is
# injected as-is.
#
# source://ox//lib/ox/raw.rb#5
class Ox::Raw < ::Ox::Node
  # Creates a new Raw element with the specified value.
  # - +value+ [String] string value for the comment
  #
  # @return [Raw] a new instance of Raw
  #
  # source://ox//lib/ox/raw.rb#8
  def initialize(value); end
end

# A SAX style parse handler. The Ox::Sax handler class should be subclasses
# and then used with the Ox.sax_parse() method. The Sax methods will then be
# called as the file is parsed. This is best suited for very large files or
# IO streams.<p/>
#
# *Example*
#
#  require 'ox'
#
#  class MySax < ::Ox::Sax
#    def initialize()
#      @element_names = []
#    end
#
#    def start_element(name)
#      @element_names << name
#    end
#  end
#
#  any = MySax.new()
#  File.open('any.xml', 'r') do |f|
#    Ox.sax_parse(any, f)
#  end
#
# To make the desired methods active while parsing the desired method should
# be made public in the subclasses. If the methods remain private they will
# not be called during parsing. The 'name' argument in the callback methods
# will be a Symbol. The 'str' arguments will be a String. The 'value'
# arguments will be Ox::Sax::Value objects. Since both the text() and the
# value() methods are called for the same element in the XML document the the
# text() method is ignored if the value() method is defined or public. The
# same is true for attr() and attr_value(). When all attributes have been read
# the attr_done() callback will be invoked.
#
#    def instruct(target); end
#    def end_instruct(target); end
#    def attr(name, str); end
#    def attr_value(name, value); end
#    def attrs_done(); end
#    def doctype(str); end
#    def comment(str); end
#    def cdata(str); end
#    def text(str); end
#    def value(value); end
#    def start_element(name); end
#    def end_element(name); end
#    def error(message, line, column); end
#    def abort(name); end
#
# Initializing _line_ attribute in the initializer will cause that variable to
# be updated before each callback with the XML line number. The same is true
# for the _column_ attribute but it will be updated with the column in the XML
# file that is the start of the element or node just read. @pos if defined
# will hold the number of bytes from the start of the document.
#
# source://ox//lib/ox/sax.rb#56
class Ox::Sax
  # Create a new instance of the Sax handler class.
  #
  # @return [Sax] a new instance of Sax
  #
  # source://ox//lib/ox/sax.rb#58
  def initialize; end

  private

  # source://ox//lib/ox/sax.rb#95
  def abort(name); end

  # source://ox//lib/ox/sax.rb#73
  def attr(name, str); end

  # source://ox//lib/ox/sax.rb#75
  def attr_value(name, value); end

  # source://ox//lib/ox/sax.rb#77
  def attrs_done; end

  # source://ox//lib/ox/sax.rb#83
  def cdata(str); end

  # source://ox//lib/ox/sax.rb#81
  def comment(str); end

  # source://ox//lib/ox/sax.rb#79
  def doctype(str); end

  # source://ox//lib/ox/sax.rb#91
  def end_element(name); end

  # source://ox//lib/ox/sax.rb#71
  def end_instruct(target); end

  # source://ox//lib/ox/sax.rb#93
  def error(message, line, column); end

  # source://ox//lib/ox/sax.rb#69
  def instruct(target); end

  # source://ox//lib/ox/sax.rb#89
  def start_element(name); end

  # source://ox//lib/ox/sax.rb#85
  def text(str); end

  # source://ox//lib/ox/sax.rb#87
  def value(value); end
end

class Ox::Sax::Value
  def as_bool; end
  def as_f; end
  def as_i; end
  def as_s; end
  def as_sym; end
  def as_time; end
  def empty?; end
end

# An Exception that is raised as a result of invalid XML syntax.
#
# source://ox//lib/ox/error.rb#15
class Ox::SyntaxError < ::Ox::Error; end

# Current version of the module.
#
# source://ox//lib/ox/version.rb#3
Ox::VERSION = T.let(T.unsafe(nil), String)
